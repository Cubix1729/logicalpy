{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"LogicalPy","text":"<p>LogicalPy is a small Python library providing basic functionalities for manipulating propositional logic.</p>"},{"location":"#description","title":"Description","text":"<p>The library allows to work with classical propositional logic formulae. The main features include:</p> <ul> <li>The construction of logical formulae either directly or from a string</li> <li>The visualisation of truth tables</li> <li>The implementation of semantic notions: satisfiability, entailment...</li> <li>The conversion to normal forms (NNF, CNF, or DNF)</li> <li>Automated theorem proving with the resolution procedure</li> </ul>"},{"location":"#installation","title":"Installation","text":"<p>With pip: <pre><code>pip install logicalpy\n</code></pre></p> <p>Note that the library needs a Python version higher than 3.9.</p>"},{"location":"#usage","title":"Usage","text":"<p>For getting started, see the usage section.</p> <p>For a complete project reference, see the API Reference.</p>"},{"location":"#contributing","title":"Contributing","text":"<p>If you want to contribute to this (small) project, you can open an issue to report a bug or request a feature, or make a pull request.</p>"},{"location":"#tests","title":"Tests","text":"<p>To run the the tests, clone the repository, go into the <code>tests</code> directory and run <code>python -m unittest</code>.</p>"},{"location":"#license","title":"License","text":"<p>This project is licensed under the MIT license.</p>"},{"location":"api-reference/summary/","title":"Summary","text":"<ul> <li>logicalpy<ul> <li>base</li> <li>normal_forms</li> <li>resolution</li> <li>semantics</li> </ul> </li> </ul>"},{"location":"api-reference/logicalpy/","title":"logicalpy","text":""},{"location":"api-reference/logicalpy/base/","title":"base","text":""},{"location":"api-reference/logicalpy/base/#logicalpy.base.And","title":"<code>And</code>","text":"<p>               Bases: <code>_TwoPlaceConnective</code></p> <p>A class representing logical conjunction</p> <p>Attributes:</p> Name Type Description <code>a</code> <p>the left hand part of the conjunction</p> <code>b</code> <p>the right hand part of the conjunction</p> Source code in <code>src\\logicalpy\\base.py</code> <pre><code>class And(_TwoPlaceConnective):\n    \"\"\"A class representing logical conjunction\n\n    Attributes:\n        a: the left hand part of the conjunction\n        b: the right hand part of the conjunction\n    \"\"\"\n\n    CONNECTIVE_SYMBOL = \"\u2227\"\n    LATEX_SYMBOL = r\"\\land\"\n\n    def is_satisfied(self, valuation: dict[str, bool]) -&gt; bool:\n        return self.a.is_satisfied(valuation) and self.b.is_satisfied(valuation)\n\n    def _distribute_and_over_or(self):\n        if isinstance(self.b, Or):\n            return Or(And(self.a, self.b.a)._distribute_and_over_or(), And(self.a, self.b.b)._distribute_and_over_or())\n        elif isinstance(self.a, Or):\n            return Or(And(self.b, self.a.a)._distribute_and_over_or(), And(self.b, self.a.b)._distribute_and_over_or())\n        else:\n            return And(self.a._distribute_and_over_or(), self.b._distribute_and_over_or())\n</code></pre>"},{"location":"api-reference/logicalpy/base/#logicalpy.base.BiImplies","title":"<code>BiImplies</code>","text":"<p>               Bases: <code>_TwoPlaceConnective</code></p> <p>A class representing logical bi-implication (also called biconditional)</p> <p>Attributes:</p> Name Type Description <code>a</code> <p>the left hand part of the biconditional</p> <code>b</code> <p>the right hand part of the biconditional</p> Source code in <code>src\\logicalpy\\base.py</code> <pre><code>class BiImplies(_TwoPlaceConnective):\n    \"\"\"A class representing logical bi-implication (also called biconditional)\n\n    Attributes:\n        a: the left hand part of the biconditional\n        b: the right hand part of the biconditional\n    \"\"\"\n\n    CONNECTIVE_SYMBOL = \"\u2194\"\n    LATEX_SYMBOL = r\"\\leftrightarrow\"\n\n    def is_satisfied(self, valuation: dict[str, bool]) -&gt; bool:\n        return self.a.is_satisfied(valuation) == self.b.is_satisfied(valuation)\n\n    def _eliminate_conditionals(self):\n        a = self.a._eliminate_conditionals()\n        b = self.b._eliminate_conditionals()\n        return And(Or(Not(a), b), Or(Not(b), a))\n</code></pre>"},{"location":"api-reference/logicalpy/base/#logicalpy.base.Formula","title":"<code>Formula</code>","text":"<p>The general class for a propositional formula</p> <p>Attributes:</p> Name Type Description <code>formula</code> <p>the formula described (can be an instance of any of the base connective classes)</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from logicalpy import Proposition, Or, Not, Formula\n&gt;&gt;&gt; P = Proposition(\"P\")\n&gt;&gt;&gt; test_formula = Formula(Or(P, Not(P)))\n&gt;&gt;&gt; str(test_formula)\n'P \u2228 \u00acP'\n&gt;&gt;&gt; test_formula.propositions()\n{'P'}\n&gt;&gt;&gt; test_formula.is_satisfied({\"P\": True})\nTrue\n&gt;&gt;&gt; print(Formula.from_string(\"P &amp; (P -&gt; P)\")\nP \u2227 (P \u2192 P)\n</code></pre> Source code in <code>src\\logicalpy\\base.py</code> <pre><code>class Formula:\n    \"\"\"The general class for a propositional formula\n\n    Attributes:\n        formula: the formula described (can be an instance of any of the base connective classes)\n\n    Examples:\n        &gt;&gt;&gt; from logicalpy import Proposition, Or, Not, Formula\n        &gt;&gt;&gt; P = Proposition(\"P\")\n        &gt;&gt;&gt; test_formula = Formula(Or(P, Not(P)))\n        &gt;&gt;&gt; str(test_formula)\n        'P \u2228 \u00acP'\n        &gt;&gt;&gt; test_formula.propositions()\n        {'P'}\n        &gt;&gt;&gt; test_formula.is_satisfied({\"P\": True})\n        True\n        &gt;&gt;&gt; print(Formula.from_string(\"P &amp; (P -&gt; P)\")\n        P \u2227 (P \u2192 P)\n\n    \"\"\"\n\n    def __init__(self, formula):\n        \"\"\"The formula's constructor\n\n        Args:\n            formula: the formula represented (can be an instance of any of the base connective classes)\n\n        \"\"\"\n        self.formula = formula\n\n    def __str__(self) -&gt; str:\n        formula_str = str(self.formula)\n        if formula_str.startswith(\"(\") and formula_str.endswith(\")\"):  # if there are outer parenthesis, we remove them\n            return formula_str[1:-1]\n        return formula_str\n\n    def __eq__(self, other) -&gt; bool:\n        if isinstance(other, Formula):\n            return self.formula == other.formula\n        return False\n\n    def __repr__(self) -&gt; str:\n        return f\"Formula({repr(self.formula)})\"\n\n    def __hash__(self) -&gt; int:\n        return hash(str(self))\n\n    def to_latex(self) -&gt; str:\n        \"\"\"Renders the formula as LaTex code\n\n        Returns:\n            (str): the LaTex representation of the formula, as inline math\n\n        \"\"\"\n        formula_latex = self.formula.to_latex()\n        if formula_latex.startswith(\"(\") and formula_latex.endswith(\n            \")\"\n        ):  # if there are outer parenthesis, we remove them\n            return \"$\" + formula_latex[1:-1] + \"$\"\n        return \"$\" + formula_latex + \"$\"\n\n    @classmethod\n    def from_string(cls, formula_str: str):\n        \"\"\"Builds a formula from a string representation of it\n\n        Args:\n            formula_str (str): the string containing the string representation of the formula\n\n        Returns:\n            (Formula): the formula built\n\n        \"\"\"\n        return cls(_interpret_formula_tree(PROPOSITIONAL_PARSER.parse(formula_str)))\n\n    def propositions(self) -&gt; set[str]:\n        \"\"\"A method for listing all the propositions of the formula\n\n        Returns:\n            (set[str]): the set of all the propositions of the formula, each represented by its name (str)\n\n        \"\"\"\n        return self.formula.propositions()\n\n    def is_satisfied(self, valuation: dict[str, bool]) -&gt; bool:\n        \"\"\"Tests whether the formula is satisfied by the truth valuation given\n\n        Args:\n            valuation (dict[str, bool]): a dictionary associating each proposition name (str) with a truth value (bool)\n\n        Returns:\n            (bool): True is the formula is satisfied by the truth valuation given, and False otherwise\n\n        Raises:\n            ValueError: if the truth value of one of the formula's propositions isn't precised in the valuation given\n\n        \"\"\"\n        return self.formula.is_satisfied(valuation)\n\n    def is_literal(self) -&gt; bool:\n        \"\"\"Tests whether the formula is a literal, i.e. a proposition or its negation\"\"\"\n        if isinstance(self.formula, Proposition):\n            return True\n        elif isinstance(self.formula, Not):\n            if isinstance(self.formula.a, Proposition):\n                return True\n        return False\n\n    def is_proposition(self) -&gt; bool:\n        \"\"\"Tests whether the formula is only a proposition\"\"\"\n        return isinstance(self.formula, Proposition)\n\n    def is_negation(self) -&gt; bool:\n        \"\"\"Tests whether the formula's main connective is a negation\"\"\"\n        return isinstance(self.formula, Not)\n\n    def is_conjunction(self) -&gt; bool:\n        \"\"\"Tests whether the formula's main connective is a conjunction\"\"\"\n        return isinstance(self.formula, And)\n\n    def is_disjunction(self) -&gt; bool:\n        \"\"\"Tests whether the formula's main connective is a disjunction\"\"\"\n        return isinstance(self.formula, Or)\n\n    def is_implication(self) -&gt; bool:\n        \"\"\"Tests whether the formula's main connective is an implication\"\"\"\n        return isinstance(self.formula, Implies)\n\n    def is_bi_implication(self) -&gt; bool:\n        \"\"\"Tests whether the formula's main connective is a bi-implication\"\"\"\n        return isinstance(self.formula, BiImplies)\n\n    def _eliminate_conditionals(self):\n        return Formula(self.formula._eliminate_conditionals())\n\n    def _move_negations_inward(self):\n        return Formula(self.formula._move_negations_inward())\n\n    def _distribute_or_over_and(self):\n        return Formula(self.formula._distribute_or_over_and())\n\n    def _distribute_and_over_or(self):\n        return Formula(self.formula._distribute_and_over_or())\n</code></pre>"},{"location":"api-reference/logicalpy/base/#logicalpy.base.Formula.__init__","title":"<code>__init__(formula)</code>","text":"<p>The formula's constructor</p> <p>Parameters:</p> Name Type Description Default <code>formula</code> <p>the formula represented (can be an instance of any of the base connective classes)</p> required Source code in <code>src\\logicalpy\\base.py</code> <pre><code>def __init__(self, formula):\n    \"\"\"The formula's constructor\n\n    Args:\n        formula: the formula represented (can be an instance of any of the base connective classes)\n\n    \"\"\"\n    self.formula = formula\n</code></pre>"},{"location":"api-reference/logicalpy/base/#logicalpy.base.Formula.from_string","title":"<code>from_string(formula_str)</code>  <code>classmethod</code>","text":"<p>Builds a formula from a string representation of it</p> <p>Parameters:</p> Name Type Description Default <code>formula_str</code> <code>str</code> <p>the string containing the string representation of the formula</p> required <p>Returns:</p> Type Description <code>Formula</code> <p>the formula built</p> Source code in <code>src\\logicalpy\\base.py</code> <pre><code>@classmethod\ndef from_string(cls, formula_str: str):\n    \"\"\"Builds a formula from a string representation of it\n\n    Args:\n        formula_str (str): the string containing the string representation of the formula\n\n    Returns:\n        (Formula): the formula built\n\n    \"\"\"\n    return cls(_interpret_formula_tree(PROPOSITIONAL_PARSER.parse(formula_str)))\n</code></pre>"},{"location":"api-reference/logicalpy/base/#logicalpy.base.Formula.is_bi_implication","title":"<code>is_bi_implication()</code>","text":"<p>Tests whether the formula's main connective is a bi-implication</p> Source code in <code>src\\logicalpy\\base.py</code> <pre><code>def is_bi_implication(self) -&gt; bool:\n    \"\"\"Tests whether the formula's main connective is a bi-implication\"\"\"\n    return isinstance(self.formula, BiImplies)\n</code></pre>"},{"location":"api-reference/logicalpy/base/#logicalpy.base.Formula.is_conjunction","title":"<code>is_conjunction()</code>","text":"<p>Tests whether the formula's main connective is a conjunction</p> Source code in <code>src\\logicalpy\\base.py</code> <pre><code>def is_conjunction(self) -&gt; bool:\n    \"\"\"Tests whether the formula's main connective is a conjunction\"\"\"\n    return isinstance(self.formula, And)\n</code></pre>"},{"location":"api-reference/logicalpy/base/#logicalpy.base.Formula.is_disjunction","title":"<code>is_disjunction()</code>","text":"<p>Tests whether the formula's main connective is a disjunction</p> Source code in <code>src\\logicalpy\\base.py</code> <pre><code>def is_disjunction(self) -&gt; bool:\n    \"\"\"Tests whether the formula's main connective is a disjunction\"\"\"\n    return isinstance(self.formula, Or)\n</code></pre>"},{"location":"api-reference/logicalpy/base/#logicalpy.base.Formula.is_implication","title":"<code>is_implication()</code>","text":"<p>Tests whether the formula's main connective is an implication</p> Source code in <code>src\\logicalpy\\base.py</code> <pre><code>def is_implication(self) -&gt; bool:\n    \"\"\"Tests whether the formula's main connective is an implication\"\"\"\n    return isinstance(self.formula, Implies)\n</code></pre>"},{"location":"api-reference/logicalpy/base/#logicalpy.base.Formula.is_literal","title":"<code>is_literal()</code>","text":"<p>Tests whether the formula is a literal, i.e. a proposition or its negation</p> Source code in <code>src\\logicalpy\\base.py</code> <pre><code>def is_literal(self) -&gt; bool:\n    \"\"\"Tests whether the formula is a literal, i.e. a proposition or its negation\"\"\"\n    if isinstance(self.formula, Proposition):\n        return True\n    elif isinstance(self.formula, Not):\n        if isinstance(self.formula.a, Proposition):\n            return True\n    return False\n</code></pre>"},{"location":"api-reference/logicalpy/base/#logicalpy.base.Formula.is_negation","title":"<code>is_negation()</code>","text":"<p>Tests whether the formula's main connective is a negation</p> Source code in <code>src\\logicalpy\\base.py</code> <pre><code>def is_negation(self) -&gt; bool:\n    \"\"\"Tests whether the formula's main connective is a negation\"\"\"\n    return isinstance(self.formula, Not)\n</code></pre>"},{"location":"api-reference/logicalpy/base/#logicalpy.base.Formula.is_proposition","title":"<code>is_proposition()</code>","text":"<p>Tests whether the formula is only a proposition</p> Source code in <code>src\\logicalpy\\base.py</code> <pre><code>def is_proposition(self) -&gt; bool:\n    \"\"\"Tests whether the formula is only a proposition\"\"\"\n    return isinstance(self.formula, Proposition)\n</code></pre>"},{"location":"api-reference/logicalpy/base/#logicalpy.base.Formula.is_satisfied","title":"<code>is_satisfied(valuation)</code>","text":"<p>Tests whether the formula is satisfied by the truth valuation given</p> <p>Parameters:</p> Name Type Description Default <code>valuation</code> <code>dict[str, bool]</code> <p>a dictionary associating each proposition name (str) with a truth value (bool)</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True is the formula is satisfied by the truth valuation given, and False otherwise</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>if the truth value of one of the formula's propositions isn't precised in the valuation given</p> Source code in <code>src\\logicalpy\\base.py</code> <pre><code>def is_satisfied(self, valuation: dict[str, bool]) -&gt; bool:\n    \"\"\"Tests whether the formula is satisfied by the truth valuation given\n\n    Args:\n        valuation (dict[str, bool]): a dictionary associating each proposition name (str) with a truth value (bool)\n\n    Returns:\n        (bool): True is the formula is satisfied by the truth valuation given, and False otherwise\n\n    Raises:\n        ValueError: if the truth value of one of the formula's propositions isn't precised in the valuation given\n\n    \"\"\"\n    return self.formula.is_satisfied(valuation)\n</code></pre>"},{"location":"api-reference/logicalpy/base/#logicalpy.base.Formula.propositions","title":"<code>propositions()</code>","text":"<p>A method for listing all the propositions of the formula</p> <p>Returns:</p> Type Description <code>set[str]</code> <p>the set of all the propositions of the formula, each represented by its name (str)</p> Source code in <code>src\\logicalpy\\base.py</code> <pre><code>def propositions(self) -&gt; set[str]:\n    \"\"\"A method for listing all the propositions of the formula\n\n    Returns:\n        (set[str]): the set of all the propositions of the formula, each represented by its name (str)\n\n    \"\"\"\n    return self.formula.propositions()\n</code></pre>"},{"location":"api-reference/logicalpy/base/#logicalpy.base.Formula.to_latex","title":"<code>to_latex()</code>","text":"<p>Renders the formula as LaTex code</p> <p>Returns:</p> Type Description <code>str</code> <p>the LaTex representation of the formula, as inline math</p> Source code in <code>src\\logicalpy\\base.py</code> <pre><code>def to_latex(self) -&gt; str:\n    \"\"\"Renders the formula as LaTex code\n\n    Returns:\n        (str): the LaTex representation of the formula, as inline math\n\n    \"\"\"\n    formula_latex = self.formula.to_latex()\n    if formula_latex.startswith(\"(\") and formula_latex.endswith(\n        \")\"\n    ):  # if there are outer parenthesis, we remove them\n        return \"$\" + formula_latex[1:-1] + \"$\"\n    return \"$\" + formula_latex + \"$\"\n</code></pre>"},{"location":"api-reference/logicalpy/base/#logicalpy.base.Implies","title":"<code>Implies</code>","text":"<p>               Bases: <code>_TwoPlaceConnective</code></p> <p>A class representing logical implication</p> <p>Attributes:</p> Name Type Description <code>a</code> <p>the left hand part of the implication</p> <code>b</code> <p>the right hand part of the implication</p> Source code in <code>src\\logicalpy\\base.py</code> <pre><code>class Implies(_TwoPlaceConnective):\n    \"\"\"A class representing logical implication\n\n    Attributes:\n        a: the left hand part of the implication\n        b: the right hand part of the implication\n    \"\"\"\n\n    CONNECTIVE_SYMBOL = \"\u2192\"\n    LATEX_SYMBOL = r\"\\to\"\n\n    def is_satisfied(self, valuation: dict[str, bool]) -&gt; bool:\n        return (not self.a.is_satisfied(valuation)) or self.b.is_satisfied(valuation)\n\n    def _eliminate_conditionals(self):\n        return Or(Not(self.a._eliminate_conditionals()), self.b._eliminate_conditionals())\n</code></pre>"},{"location":"api-reference/logicalpy/base/#logicalpy.base.Not","title":"<code>Not</code>","text":"<p>A class representing logical negation</p> <p>Attributes:</p> Name Type Description <code>a</code> <p>the negated content</p> Source code in <code>src\\logicalpy\\base.py</code> <pre><code>class Not:\n    \"\"\"A class representing logical negation\n\n    Attributes:\n        a: the negated content\n\n    \"\"\"\n\n    def __init__(self, a):\n        self.a = a\n\n    def __str__(self) -&gt; str:\n        return f\"\u00ac{self.a}\"\n\n    def __eq__(self, other) -&gt; bool:\n        if isinstance(other, Not):\n            return self.a == other.a\n        return False\n\n    def __repr__(self) -&gt; str:\n        return f\"Not({repr(self.a)})\"\n\n    def to_latex(self) -&gt; str:\n        return r\"\\neg \" + self.a.to_latex()\n\n    def propositions(self) -&gt; set[str]:\n        return self.a.propositions()\n\n    def is_satisfied(self, valuation: dict[str, bool]) -&gt; bool:\n        return not self.a.is_satisfied(valuation)\n\n    def __and__(self, other):\n        return And(self, other)\n\n    def __or__(self, other):\n        return Or(self, other)\n\n    def __rshift__(self, other):\n        return Implies(self, other)\n\n    def __invert__(self):\n        return Not(self)\n\n    def _eliminate_conditionals(self):\n        return Not(self.a._eliminate_conditionals())\n\n    def _move_negations_inward(self):\n        if isinstance(self.a, Not):  # double negation elimination\n            return self.a.a._move_negations_inward()\n        elif isinstance(self.a, And):  # De Morgan's law #1 (~(A &amp; B) &lt;-&gt; ~A v ~B)\n            return Or(Not(self.a.a)._move_negations_inward(), Not(self.a.b)._move_negations_inward())\n        elif isinstance(self.a, Or):  # De Morgan's law #2 (~(A v B) &lt;-&gt; ~A &amp; ~B)\n            return And(Not(self.a.a)._move_negations_inward(), Not(self.a.b)._move_negations_inward())\n        else:  # matches no rule\n            return self\n\n    def _distribute_or_over_and(self):\n        return Not(self.a._distribute_or_over_and())\n\n    def _distribute_and_over_or(self):\n        return Not(self.a._distribute_and_over_or())\n</code></pre>"},{"location":"api-reference/logicalpy/base/#logicalpy.base.Or","title":"<code>Or</code>","text":"<p>               Bases: <code>_TwoPlaceConnective</code></p> <p>A class representing logical disjunction</p> <p>Attributes:</p> Name Type Description <code>a</code> <p>the left hand part of the disjunction</p> <code>b</code> <p>the right hand part of the disjunction</p> Source code in <code>src\\logicalpy\\base.py</code> <pre><code>class Or(_TwoPlaceConnective):\n    \"\"\"A class representing logical disjunction\n\n    Attributes:\n        a: the left hand part of the disjunction\n        b: the right hand part of the disjunction\n    \"\"\"\n\n    CONNECTIVE_SYMBOL = \"\u2228\"\n    LATEX_SYMBOL = r\"\\lor\"\n\n    def is_satisfied(self, valuation: dict[str, bool]) -&gt; bool:\n        return self.a.is_satisfied(valuation) or self.b.is_satisfied(valuation)\n\n    def _distribute_or_over_and(self):\n        if isinstance(self.b, And):\n            return And(Or(self.a, self.b.a)._distribute_or_over_and(), Or(self.a, self.b.b)._distribute_or_over_and())\n        elif isinstance(self.a, And):\n            return And(Or(self.b, self.a.a)._distribute_or_over_and(), Or(self.b, self.a.b)._distribute_or_over_and())\n        else:\n            return Or(self.a._distribute_or_over_and(), self.b._distribute_or_over_and())\n</code></pre>"},{"location":"api-reference/logicalpy/base/#logicalpy.base.Proposition","title":"<code>Proposition</code>","text":"<p>A class representing propositions</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>the name of the proposition</p> Source code in <code>src\\logicalpy\\base.py</code> <pre><code>class Proposition:\n    \"\"\"A class representing propositions\n\n    Attributes:\n        name (str): the name of the proposition\n    \"\"\"\n\n    def __init__(self, name: str):\n        if name == \"\":\n            raise ValueError(\"a proposition name cannot be ''\")\n        self.name = name\n\n    def __str__(self) -&gt; str:\n        return self.name\n\n    def __eq__(self, other):\n        if isinstance(other, Proposition):\n            return self.name == other.name\n        return False\n\n    def __repr__(self) -&gt; str:\n        return f\"Proposition('{self.name}')\"\n\n    def to_latex(self) -&gt; str:\n        return self.name\n\n    def propositions(self) -&gt; set:\n        return {self.name}\n\n    def is_satisfied(self, valuation: dict[str, bool]) -&gt; bool:\n        try:\n            return valuation[self.name]\n        except KeyError:\n            raise ValueError(f\"proposition '{self.name}' is not associated with a value\")\n\n    def __and__(self, other):\n        return And(self, other)\n\n    def __or__(self, other):\n        return Or(self, other)\n\n    def __rshift__(self, other):\n        return Implies(self, other)\n\n    def __invert__(self):\n        return Not(self)\n\n    def _eliminate_conditionals(self):\n        return self\n\n    def _move_negations_inward(self):\n        return self\n\n    def _distribute_or_over_and(self):\n        return self\n\n    def _distribute_and_over_or(self):\n        return self\n</code></pre>"},{"location":"api-reference/logicalpy/normal_forms/","title":"normal_forms","text":""},{"location":"api-reference/logicalpy/normal_forms/#logicalpy.normal_forms.ConjunctiveClause","title":"<code>ConjunctiveClause</code>","text":"<p>A class for representing a conjunctive clause</p> <p>Attributes:</p> Name Type Description <code>literals</code> <code>tuple</code> <p>the literals of the clause</p> Note <p>Conjunctive clauses are less used than disjunctive clauses. This class is only used in DNF clausal results.</p> Source code in <code>src\\logicalpy\\normal_forms.py</code> <pre><code>class ConjunctiveClause:\n    \"\"\"A class for representing a conjunctive clause\n\n    Attributes:\n        literals (tuple): the literals of the clause\n\n    Note:\n        Conjunctive clauses are less used than disjunctive clauses. This class is only used in DNF clausal results.\n\n    \"\"\"\n\n    def __init__(self, *literals: Formula):\n        \"\"\"The clause's constructor\n\n        Args:\n            *literals (Formula): the literals of the disjunctive clause, each as a Formula\n\n        Raises:\n            ValueError: if any of the arguments given is not a literal (i.e. a proposition or its negation)\n\n        \"\"\"\n        for literal in literals:\n            if not literal.is_literal():\n                raise ValueError(f\"Formula '{literal}' is not a literal\")\n        self.literals = literals\n\n    def is_empty(self) -&gt; bool:\n        \"\"\"Tests whether the clause is empty\"\"\"\n        return len(self.literals) == 0\n\n    def __str__(self):\n        if len(self.literals) &gt;= 2:\n            return \"({})\".format(\" \u2227 \".join(str(literal) for literal in self.literals))\n        elif len(self.literals) == 1:\n            return str(self.literals[0])\n        else:\n            return \"\u25fb\"\n\n    def __repr__(self) -&gt; str:\n        return \"ConjunctiveClause({})\".format(\", \".join([repr(literal) for literal in self.literals]))\n\n    def __eq__(self, other):\n        if isinstance(other, ConjunctiveClause):\n            return set(self.literals) == set(other.literals)\n        return False\n\n    def __iter__(self):\n        return iter(self.literals)\n</code></pre>"},{"location":"api-reference/logicalpy/normal_forms/#logicalpy.normal_forms.ConjunctiveClause.__init__","title":"<code>__init__(*literals)</code>","text":"<p>The clause's constructor</p> <p>Parameters:</p> Name Type Description Default <code>*literals</code> <code>Formula</code> <p>the literals of the disjunctive clause, each as a Formula</p> <code>()</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>if any of the arguments given is not a literal (i.e. a proposition or its negation)</p> Source code in <code>src\\logicalpy\\normal_forms.py</code> <pre><code>def __init__(self, *literals: Formula):\n    \"\"\"The clause's constructor\n\n    Args:\n        *literals (Formula): the literals of the disjunctive clause, each as a Formula\n\n    Raises:\n        ValueError: if any of the arguments given is not a literal (i.e. a proposition or its negation)\n\n    \"\"\"\n    for literal in literals:\n        if not literal.is_literal():\n            raise ValueError(f\"Formula '{literal}' is not a literal\")\n    self.literals = literals\n</code></pre>"},{"location":"api-reference/logicalpy/normal_forms/#logicalpy.normal_forms.ConjunctiveClause.is_empty","title":"<code>is_empty()</code>","text":"<p>Tests whether the clause is empty</p> Source code in <code>src\\logicalpy\\normal_forms.py</code> <pre><code>def is_empty(self) -&gt; bool:\n    \"\"\"Tests whether the clause is empty\"\"\"\n    return len(self.literals) == 0\n</code></pre>"},{"location":"api-reference/logicalpy/normal_forms/#logicalpy.normal_forms.DisjunctiveClause","title":"<code>DisjunctiveClause</code>","text":"<p>A class for representing a disjunctive clause</p> <p>Attributes:</p> Name Type Description <code>literals</code> <code>tuple</code> <p>the literals of the clause</p> Source code in <code>src\\logicalpy\\normal_forms.py</code> <pre><code>class DisjunctiveClause:\n    \"\"\"A class for representing a disjunctive clause\n\n    Attributes:\n        literals (tuple): the literals of the clause\n\n    \"\"\"\n\n    def __init__(self, *literals: Formula):\n        \"\"\"The clause's constructor\n\n        Args:\n            *literals (Formula): the literals of the disjunctive clause, each as a Formula\n\n        Raises:\n            ValueError: if any of the arguments given is not a literal (i.e. a proposition or its negation)\n\n        \"\"\"\n        for literal in literals:\n            if not literal.is_literal():\n                raise ValueError(f\"Formula '{literal}' is not a literal\")\n        self.literals = literals\n\n    def is_empty(self) -&gt; bool:\n        \"\"\"Tests whether the clause is empty\"\"\"\n        return len(self.literals) == 0\n\n    def __str__(self):\n        if len(self.literals) &gt;= 2:\n            return \"({})\".format(\" \u2228 \".join(str(literal) for literal in self.literals))\n        elif len(self.literals) == 1:\n            return str(self.literals[0])\n        else:\n            return \"\u25fb\"\n\n    def __repr__(self) -&gt; str:\n        return \"DisjunctiveClause({})\".format(\", \".join([repr(literal) for literal in self.literals]))\n\n    def __eq__(self, other):\n        if isinstance(other, DisjunctiveClause):\n            return set(self.literals) == set(other.literals)\n        return False\n\n    def __iter__(self):\n        return iter(self.literals)\n</code></pre>"},{"location":"api-reference/logicalpy/normal_forms/#logicalpy.normal_forms.DisjunctiveClause.__init__","title":"<code>__init__(*literals)</code>","text":"<p>The clause's constructor</p> <p>Parameters:</p> Name Type Description Default <code>*literals</code> <code>Formula</code> <p>the literals of the disjunctive clause, each as a Formula</p> <code>()</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>if any of the arguments given is not a literal (i.e. a proposition or its negation)</p> Source code in <code>src\\logicalpy\\normal_forms.py</code> <pre><code>def __init__(self, *literals: Formula):\n    \"\"\"The clause's constructor\n\n    Args:\n        *literals (Formula): the literals of the disjunctive clause, each as a Formula\n\n    Raises:\n        ValueError: if any of the arguments given is not a literal (i.e. a proposition or its negation)\n\n    \"\"\"\n    for literal in literals:\n        if not literal.is_literal():\n            raise ValueError(f\"Formula '{literal}' is not a literal\")\n    self.literals = literals\n</code></pre>"},{"location":"api-reference/logicalpy/normal_forms/#logicalpy.normal_forms.DisjunctiveClause.is_empty","title":"<code>is_empty()</code>","text":"<p>Tests whether the clause is empty</p> Source code in <code>src\\logicalpy\\normal_forms.py</code> <pre><code>def is_empty(self) -&gt; bool:\n    \"\"\"Tests whether the clause is empty\"\"\"\n    return len(self.literals) == 0\n</code></pre>"},{"location":"api-reference/logicalpy/normal_forms/#logicalpy.normal_forms.to_clausal_cnf","title":"<code>to_clausal_cnf(formula)</code>","text":"<p>Converts a formula to conjunctive normal form (CNF) like <code>to_cnf</code>, but as a list of disjunctive clauses</p> <p>Parameters:</p> Name Type Description Default <code>formula</code> <code>Formula</code> <p>the formula to convert</p> required <p>Returns:</p> Type Description <code>list[DisjunctiveClause]</code> <p>the resulting CNF form, as a list of disjunctive clauses representing their conjunction</p> Source code in <code>src\\logicalpy\\normal_forms.py</code> <pre><code>def to_clausal_cnf(formula: Formula) -&gt; list[DisjunctiveClause]:\n    \"\"\"Converts a formula to conjunctive normal form (CNF) like `to_cnf`, but as a list of disjunctive clauses\n\n    Args:\n        formula (Formula): the formula to convert\n\n    Returns:\n        (list[DisjunctiveClause]): the resulting CNF form, as a list of disjunctive clauses representing their conjunction\n\n    \"\"\"\n\n    formula = to_cnf(formula).formula  # we are manipulating connectives objects, not Formula objects\n    conjuncts_list = _find_conjuncts(formula)\n\n    list_of_clauses = []\n\n    for conjunct in conjuncts_list:\n        list_of_clauses.append(DisjunctiveClause(*_find_disjuncts(conjunct.formula)))\n\n    return list_of_clauses\n</code></pre>"},{"location":"api-reference/logicalpy/normal_forms/#logicalpy.normal_forms.to_clausal_dnf","title":"<code>to_clausal_dnf(formula)</code>","text":"<p>Converts a formula to disjunctive normal form (DNF) like <code>to_dnf</code>, but as a list of conjunctive clauses</p> <p>Parameters:</p> Name Type Description Default <code>formula</code> <code>Formula</code> <p>the formula to convert</p> required <p>Returns:</p> Type Description <code>list[ConjunctiveClause]</code> <p>the resulting DNF form, as a list of conjunctive clauses representing their disjunction</p> Source code in <code>src\\logicalpy\\normal_forms.py</code> <pre><code>def to_clausal_dnf(formula: Formula) -&gt; list[ConjunctiveClause]:\n    \"\"\"Converts a formula to disjunctive normal form (DNF) like `to_dnf`, but as a list of conjunctive clauses\n\n    Args:\n        formula (Formula): the formula to convert\n\n    Returns:\n        (list[ConjunctiveClause]): the resulting DNF form, as a list of conjunctive clauses representing their disjunction\n\n    \"\"\"\n\n    formula = to_dnf(formula).formula  # we are manipulating connectives objects, not Formula objects\n    disjuncts_list = _find_disjuncts(formula)\n\n    list_of_clauses = []\n\n    for disjunct in disjuncts_list:\n        list_of_clauses.append(ConjunctiveClause(*_find_conjuncts(disjunct.formula)))\n\n    return list_of_clauses\n</code></pre>"},{"location":"api-reference/logicalpy/normal_forms/#logicalpy.normal_forms.to_cnf","title":"<code>to_cnf(formula)</code>","text":"<p>Converts a formula to conjunctive normal form (CNF)</p> <p>Parameters:</p> Name Type Description Default <code>formula</code> <code>Formula</code> <p>the formula to convert</p> required <p>Returns:</p> Type Description <code>Formula</code> <p>the resulting formula in CNF</p> Note <p>This function does not always return the canonical CNF form of the formula. It instead uses syntactic rewriting rules to convert a formula to CNF</p> Source code in <code>src\\logicalpy\\normal_forms.py</code> <pre><code>def to_cnf(formula: Formula) -&gt; Formula:\n    \"\"\"Converts a formula to conjunctive normal form (CNF)\n\n    Args:\n        formula (Formula): the formula to convert\n\n    Returns:\n        (Formula): the resulting formula in CNF\n\n    Note:\n        This function does not always return the canonical CNF form of the formula. It instead uses syntactic rewriting\n        rules to convert a formula to CNF\n\n    \"\"\"\n\n    formula = to_nnf(formula)\n\n    old_formula = formula\n    formula = formula._distribute_or_over_and()\n\n    while old_formula != formula:\n        old_formula = formula\n        formula = formula._distribute_or_over_and()\n\n    return formula\n</code></pre>"},{"location":"api-reference/logicalpy/normal_forms/#logicalpy.normal_forms.to_dnf","title":"<code>to_dnf(formula)</code>","text":"<p>Converts a formula to disjunctive normal form (DNF)</p> <p>Parameters:</p> Name Type Description Default <code>formula</code> <code>Formula</code> <p>the formula to convert</p> required <p>Returns:</p> Type Description <code>Formula</code> <p>the resulting formula in DNF</p> Note <p>This function does not always return the canonical DNF form of the formula. It instead uses syntactic rewriting rules to convert a formula to DNF</p> Source code in <code>src\\logicalpy\\normal_forms.py</code> <pre><code>def to_dnf(formula: Formula) -&gt; Formula:\n    \"\"\"Converts a formula to disjunctive normal form (DNF)\n\n    Args:\n        formula (Formula): the formula to convert\n\n    Returns:\n        (Formula): the resulting formula in DNF\n\n    Note:\n        This function does not always return the canonical DNF form of the formula. It instead uses syntactic rewriting\n        rules to convert a formula to DNF\n\n    \"\"\"\n\n    formula = to_nnf(formula)\n\n    old_formula = formula\n    formula = formula._distribute_and_over_or()\n\n    while old_formula != formula:\n        old_formula = formula\n        formula = formula._distribute_and_over_or()\n\n    return formula\n</code></pre>"},{"location":"api-reference/logicalpy/normal_forms/#logicalpy.normal_forms.to_nnf","title":"<code>to_nnf(formula)</code>","text":"<p>Converts a formula to negation normal form (NNF), with no implications or bi-implications and all negations directly applied to propositions</p> <p>Parameters:</p> Name Type Description Default <code>formula</code> <code>Formula</code> <p>the formula to convert</p> required <p>Returns:</p> Type Description <code>Formula</code> <p>the resulting formula in NNF</p> Source code in <code>src\\logicalpy\\normal_forms.py</code> <pre><code>def to_nnf(formula: Formula) -&gt; Formula:\n    \"\"\"Converts a formula to negation normal form (NNF), with no implications or bi-implications and\n    all negations directly applied to propositions\n\n    Args:\n        formula (Formula): the formula to convert\n\n    Returns:\n        (Formula): the resulting formula in NNF\n\n    \"\"\"\n\n    formula = formula._eliminate_conditionals()\n    formula = formula._move_negations_inward()\n\n    return formula\n</code></pre>"},{"location":"api-reference/logicalpy/resolution/","title":"resolution","text":""},{"location":"api-reference/logicalpy/resolution/#logicalpy.resolution.ResolutionProver","title":"<code>ResolutionProver</code>","text":"<p>A class implementing a prover based on the resolution procedure</p> <p>Attributes:</p> Name Type Description <code>premises</code> <code>Iterable[Formula]</code> <p>the premises of the argument to prove</p> <code>conclusion</code> <code>Formula</code> <p>the conclusion to prove from the premises (whose contrary would have to be refuted)</p> Source code in <code>src\\logicalpy\\resolution.py</code> <pre><code>class ResolutionProver:\n    \"\"\"A class implementing a prover based on the resolution procedure\n\n    Attributes:\n        premises (Iterable[Formula]): the premises of the argument to prove\n        conclusion (Formula): the conclusion to prove from the premises (whose contrary would have to be refuted)\n\n    \"\"\"\n\n    def __init__(self, premises: Iterable[Formula], conclusion: Formula):\n        \"\"\"The prover's constructor\n\n        Args:\n            premises (Iterable[Formula]): the premises of the argument to prove\n            conclusion (Formula): the conclusion of the argument\n\n        \"\"\"\n\n        self.premises = premises\n        self.conclusion = conclusion\n\n        # We convert the premises to a list of clauses\n\n        all_clauses = []\n        for premise in premises:\n            cnf_form = to_clausal_cnf(premise)\n\n            for clause in cnf_form:\n                clause = _remove_redundancy(clause)\n                if not (_is_tautology(clause) or clause in all_clauses):  # remove tautologies or redundant clauses\n                    all_clauses.append(clause)\n\n        # We store the index in the clauses of the last premise clause (so the next one is the start of the negation of the conclusion)\n        self._premises_end_index = len(all_clauses)\n\n        # We negate the conclusion and add it to the clauses\n\n        negated_conclusion = Formula(Not(conclusion.formula))\n\n        negated_conclusion_cnf = to_clausal_cnf(negated_conclusion)\n\n        for clause in negated_conclusion_cnf:\n            clause = _remove_redundancy(clause)\n            if not (_is_tautology(clause) or clause in all_clauses):\n                all_clauses.append(clause)\n\n        self._all_clauses = all_clauses\n        self._refutation_found = False\n        self._terminated_without_refutation = False\n\n    def _apply_resolution(self) -&gt; Optional[tuple[DisjunctiveClause, int, int]]:\n        \"\"\"Resolves two clauses if possible and changes `all_clauses` in consideration. The clauses that were resolved are removed, and the resolvent is added.\n\n        Returns:\n            (Optional[tuple[DisjunctiveClause, int, int]]): the resulting resolved clause as well as the indexes of two\n            clauses from which it was derived if possible, and None otherwise\n\n        \"\"\"\n\n        # We first look for a contradiction\n        for clause_1, clause_2 in combinations(self._all_clauses, 2):\n            if len(clause_1.literals) == len(clause_2.literals) == 1:  # the two clauses only have one literal each\n                resolvent = resolve(clause_1, clause_2)\n\n                if resolvent is not None:  # we have found a contradiction\n                    self._all_clauses.append(resolvent)\n                    self._refutation_found = True\n\n                    return resolvent, self._all_clauses.index(clause_1), self._all_clauses.index(clause_2)\n\n        # We then look for two clauses to be resolved\n        for clause_1, clause_2 in combinations(self._all_clauses, 2):\n            resolvent = resolve(clause_1, clause_2)\n\n            if resolvent is not None:\n                resolvent = _remove_redundancy(resolvent)\n\n                if resolvent in self._all_clauses or _is_tautology(resolvent):\n                    continue\n\n                self._all_clauses.append(resolvent)\n\n                if resolvent.is_empty():\n                    self._refutation_found = True\n\n                return resolvent, self._all_clauses.index(clause_1), self._all_clauses.index(clause_2)\n\n        self._terminated_without_refutation = True\n        return None\n\n    def prove(self) -&gt; tuple[bool, str]:\n        \"\"\"Solves the goal given to the constructor by refutation, with the resolution procedure\n\n        Returns:\n            (bool): whether a refutation was found from the negated conclusion and the premises, i.e. whether the conclusion is valid given the premises\n            (str): the full refutation proof as text\n\n        \"\"\"\n\n        proof_finished = False\n        proof_str = \"Resolution proof for argument {0} \u2234 {1}\\n\\n\".format(\n            \", \".join([str(premise) for premise in self.premises]), str(self.conclusion)\n        )\n        line_num = 1\n\n        for clause in self._all_clauses[: self._premises_end_index]:\n            proof_str += f\"{line_num}. {clause}\".ljust(30) + \"Premise clause\\n\"\n            line_num += 1\n\n        for clause in self._all_clauses[self._premises_end_index :]:\n            proof_str += f\"{line_num}. {clause}\".ljust(30) + \"Negated conclusion clause\\n\"\n            line_num += 1\n\n        while not (self._terminated_without_refutation or self._refutation_found):\n            result = self._apply_resolution()\n            if result is not None:\n                resolvent, index_1, index_2 = result\n                proof_str += f\"{line_num}. {resolvent}\".ljust(30) + f\"Resolve {index_1 + 1}, {index_2 + 1}\\n\"\n            line_num += 1\n\n        if self._terminated_without_refutation:\n            proof_str += \"\\nNo refutation found: conclusion invalid\"\n            return False, proof_str\n\n        else:  # refutation found\n            proof_str += \"\\nRefutation found: conclusion valid\"\n            return True, proof_str\n</code></pre>"},{"location":"api-reference/logicalpy/resolution/#logicalpy.resolution.ResolutionProver.__init__","title":"<code>__init__(premises, conclusion)</code>","text":"<p>The prover's constructor</p> <p>Parameters:</p> Name Type Description Default <code>premises</code> <code>Iterable[Formula]</code> <p>the premises of the argument to prove</p> required <code>conclusion</code> <code>Formula</code> <p>the conclusion of the argument</p> required Source code in <code>src\\logicalpy\\resolution.py</code> <pre><code>def __init__(self, premises: Iterable[Formula], conclusion: Formula):\n    \"\"\"The prover's constructor\n\n    Args:\n        premises (Iterable[Formula]): the premises of the argument to prove\n        conclusion (Formula): the conclusion of the argument\n\n    \"\"\"\n\n    self.premises = premises\n    self.conclusion = conclusion\n\n    # We convert the premises to a list of clauses\n\n    all_clauses = []\n    for premise in premises:\n        cnf_form = to_clausal_cnf(premise)\n\n        for clause in cnf_form:\n            clause = _remove_redundancy(clause)\n            if not (_is_tautology(clause) or clause in all_clauses):  # remove tautologies or redundant clauses\n                all_clauses.append(clause)\n\n    # We store the index in the clauses of the last premise clause (so the next one is the start of the negation of the conclusion)\n    self._premises_end_index = len(all_clauses)\n\n    # We negate the conclusion and add it to the clauses\n\n    negated_conclusion = Formula(Not(conclusion.formula))\n\n    negated_conclusion_cnf = to_clausal_cnf(negated_conclusion)\n\n    for clause in negated_conclusion_cnf:\n        clause = _remove_redundancy(clause)\n        if not (_is_tautology(clause) or clause in all_clauses):\n            all_clauses.append(clause)\n\n    self._all_clauses = all_clauses\n    self._refutation_found = False\n    self._terminated_without_refutation = False\n</code></pre>"},{"location":"api-reference/logicalpy/resolution/#logicalpy.resolution.ResolutionProver.prove","title":"<code>prove()</code>","text":"<p>Solves the goal given to the constructor by refutation, with the resolution procedure</p> <p>Returns:</p> Type Description <code>bool</code> <p>whether a refutation was found from the negated conclusion and the premises, i.e. whether the conclusion is valid given the premises</p> <code>str</code> <p>the full refutation proof as text</p> Source code in <code>src\\logicalpy\\resolution.py</code> <pre><code>def prove(self) -&gt; tuple[bool, str]:\n    \"\"\"Solves the goal given to the constructor by refutation, with the resolution procedure\n\n    Returns:\n        (bool): whether a refutation was found from the negated conclusion and the premises, i.e. whether the conclusion is valid given the premises\n        (str): the full refutation proof as text\n\n    \"\"\"\n\n    proof_finished = False\n    proof_str = \"Resolution proof for argument {0} \u2234 {1}\\n\\n\".format(\n        \", \".join([str(premise) for premise in self.premises]), str(self.conclusion)\n    )\n    line_num = 1\n\n    for clause in self._all_clauses[: self._premises_end_index]:\n        proof_str += f\"{line_num}. {clause}\".ljust(30) + \"Premise clause\\n\"\n        line_num += 1\n\n    for clause in self._all_clauses[self._premises_end_index :]:\n        proof_str += f\"{line_num}. {clause}\".ljust(30) + \"Negated conclusion clause\\n\"\n        line_num += 1\n\n    while not (self._terminated_without_refutation or self._refutation_found):\n        result = self._apply_resolution()\n        if result is not None:\n            resolvent, index_1, index_2 = result\n            proof_str += f\"{line_num}. {resolvent}\".ljust(30) + f\"Resolve {index_1 + 1}, {index_2 + 1}\\n\"\n        line_num += 1\n\n    if self._terminated_without_refutation:\n        proof_str += \"\\nNo refutation found: conclusion invalid\"\n        return False, proof_str\n\n    else:  # refutation found\n        proof_str += \"\\nRefutation found: conclusion valid\"\n        return True, proof_str\n</code></pre>"},{"location":"api-reference/logicalpy/resolution/#logicalpy.resolution.are_complementary_literals","title":"<code>are_complementary_literals(literal_1, literal_2)</code>","text":"<p>A function to test whether two literals are complementary</p> <p>Parameters:</p> Name Type Description Default <code>literal_1</code> <code>Formula</code> <p>the first literal</p> required <code>literal_2</code> <code>Formula</code> <p>the second literal</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the two literals are complementary, False otherwise</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>if any of the two formulae given isn't a literal</p> Source code in <code>src\\logicalpy\\resolution.py</code> <pre><code>def are_complementary_literals(literal_1: Formula, literal_2: Formula) -&gt; bool:\n    \"\"\"A function to test whether two literals are complementary\n\n    Args:\n        literal_1 (Formula): the first literal\n        literal_2 (Formula): the second literal\n\n    Returns:\n        (bool): True if the two literals are complementary, False otherwise\n\n    Raises:\n        ValueError: if any of the two formulae given isn't a literal\n\n    \"\"\"\n\n    if not literal_1.is_literal():\n        raise ValueError(f\"formula '{literal_1}' is not a literal\")\n    if not literal_2.is_literal():\n        raise ValueError(f\"formula '{literal_2}' is not a literal\")\n\n    if literal_2.is_proposition() and literal_1.is_negation() and literal_1.formula.a == literal_2.formula:\n        return True\n    elif literal_1.is_proposition() and literal_2.is_negation() and literal_2.formula.a == literal_1.formula:\n        return True\n\n    return False\n</code></pre>"},{"location":"api-reference/logicalpy/resolution/#logicalpy.resolution.resolve","title":"<code>resolve(clause_1, clause_2)</code>","text":"<p>A function for apply the resolution inference rule to two disjunctive clauses</p> <p>Parameters:</p> Name Type Description Default <code>clause_1</code> <code>DisjunctiveClause</code> <p>the first clause to resolve</p> required <code>clause_2</code> <code>DisjunctiveClause</code> <p>the second clause to resolve</p> required <p>Returns:</p> Type Description <code>Optional[DisjunctiveClause]</code> <p>the resulting resolved (disjunctive) clause if the two given clauses are resolvable, and None otherwise</p> Source code in <code>src\\logicalpy\\resolution.py</code> <pre><code>def resolve(clause_1: DisjunctiveClause, clause_2: DisjunctiveClause) -&gt; Optional[DisjunctiveClause]:\n    \"\"\"A function for apply the resolution inference rule to two disjunctive clauses\n\n    Args:\n        clause_1 (DisjunctiveClause): the first clause to resolve\n        clause_2 (DisjunctiveClause): the second clause to resolve\n\n    Returns:\n        (Optional[DisjunctiveClause]): the resulting resolved (disjunctive) clause if the two given clauses are resolvable, and None otherwise\n\n    \"\"\"\n\n    for literal_1 in clause_1:\n        for literal_2 in clause_2:\n            if are_complementary_literals(literal_1, literal_2):\n                resulting_literals = []\n\n                for literal in clause_1:\n                    if literal != literal_1 and literal != literal_2:\n                        resulting_literals.append(literal)\n                for literal in clause_2:\n                    if literal != literal_1 and literal != literal_2:\n                        resulting_literals.append(literal)\n\n                return DisjunctiveClause(*resulting_literals)\n</code></pre>"},{"location":"api-reference/logicalpy/semantics/","title":"semantics","text":""},{"location":"api-reference/logicalpy/semantics/#logicalpy.semantics.TruthTable","title":"<code>TruthTable</code>","text":"<p>A class representing a truth table</p> Source code in <code>src\\logicalpy\\semantics.py</code> <pre><code>class TruthTable:\n    \"\"\"A class representing a truth table\"\"\"\n\n    def __init__(self, formula: Formula):\n        \"\"\"The truth table's constructor\n\n        Args:\n            formula (Formula): the formula to build the truth table for\n\n        \"\"\"\n\n        self.formula = formula\n\n        # Attributes storing return values for more efficiency\n        self._str_table = None\n        self._markdown_table = None\n        self._latex_table = None\n\n    def to_str(self) -&gt; str:\n        \"\"\"Renders the truth table as a str with the `tabulate` library (style used: 'simple')\n\n        Returns:\n            (str): the truth table\n\n        \"\"\"\n\n        if self._str_table is not None:\n            return self._str_table\n\n        table_data = []\n\n        formula_props = sorted(list(self.formula.propositions()))\n        table_headers = formula_props + [str(self.formula)]\n\n        truth_valuations_possible = product((True, False), repeat=len(formula_props))\n\n        for valuation in truth_valuations_possible:\n            valuation_dict = {prop: value for (prop, value) in zip(formula_props, valuation)}\n            if self.formula.is_satisfied(valuation_dict):\n                truth_value = \"T\"\n            else:\n                truth_value = \"F\"\n\n            table_data.append([\"T\" if val is True else \"F\" for val in valuation] + [truth_value])\n\n        self._str_table = tabulate(table_data, headers=table_headers, tablefmt=\"simple\")\n        return self._str_table\n\n    def __str__(self) -&gt; str:\n        return self.to_str()\n\n    def __repr__(self) -&gt; str:\n        return f\"TruthTable({self.formula})\"\n\n    def to_markdown(self) -&gt; str:\n        \"\"\"Renders the truth table as Markdown with the `tabulate` library\n\n        Returns:\n            (str): the Markdown truth table\n\n        \"\"\"\n\n        if self._markdown_table is not None:\n            return self._markdown_table\n\n        table_data = []\n\n        formula_props = sorted(list(self.formula.propositions()))\n        table_headers = formula_props + [str(self.formula)]\n\n        truth_valuations_possible = product((True, False), repeat=len(formula_props))\n\n        for valuation in truth_valuations_possible:\n            valuation_dict = {prop: value for (prop, value) in zip(formula_props, valuation)}\n            if self.formula.is_satisfied(valuation_dict):\n                truth_value = \"T\"\n            else:\n                truth_value = \"F\"\n\n            table_data.append([\"T\" if val is True else \"F\" for val in valuation] + [truth_value])\n\n        self._str_table = tabulate(table_data, headers=table_headers, tablefmt=\"github\")\n        return self._str_table\n\n    def to_latex(self) -&gt; str:\n        \"\"\"Renders the truth table as LaTex (with the `tabulate` library)\n\n        Returns:\n            (str): the LaTex output, which uses the `tabular` LaTex environment\n\n        \"\"\"\n        if self._latex_table is not None:\n            return self._latex_table\n\n        table_data = []\n\n        formula_props = sorted(list(self.formula.propositions()))\n        table_headers = formula_props + [self.formula.to_latex()]\n\n        truth_valuations_possible = product((True, False), repeat=len(formula_props))\n\n        for valuation in truth_valuations_possible:\n            valuation_dict = {prop: value for (prop, value) in zip(formula_props, valuation)}\n            if self.formula.is_satisfied(valuation_dict):\n                truth_value = \"T\"\n            else:\n                truth_value = \"F\"\n\n            table_data.append([\"T\" if val is True else \"F\" for val in valuation] + [truth_value])\n\n        latex_result = tabulate(table_data, headers=table_headers, tablefmt=\"latex_raw\")\n        # Add vertical bars between columns and remove very first horizontal bar\n        latex_result = re.sub(\n            r\"begin\\{tabular\\}\\{.+\\}\\n\\\\hline\",\n            r\"begin{tabular}{\" + \"|\".join([\"c\" for _ in range(len(table_headers))]) + \"}\",\n            latex_result,\n            count=1,\n        )\n        # Remove last horizontal bar\n        latex_result = latex_result.replace(r\"\\hline\" + \"\\n\" + r\"\\end{tabular}\", r\"\\end{tabular}\")\n        self._latex_table = latex_result\n        return self._latex_table\n</code></pre>"},{"location":"api-reference/logicalpy/semantics/#logicalpy.semantics.TruthTable.__init__","title":"<code>__init__(formula)</code>","text":"<p>The truth table's constructor</p> <p>Parameters:</p> Name Type Description Default <code>formula</code> <code>Formula</code> <p>the formula to build the truth table for</p> required Source code in <code>src\\logicalpy\\semantics.py</code> <pre><code>def __init__(self, formula: Formula):\n    \"\"\"The truth table's constructor\n\n    Args:\n        formula (Formula): the formula to build the truth table for\n\n    \"\"\"\n\n    self.formula = formula\n\n    # Attributes storing return values for more efficiency\n    self._str_table = None\n    self._markdown_table = None\n    self._latex_table = None\n</code></pre>"},{"location":"api-reference/logicalpy/semantics/#logicalpy.semantics.TruthTable.to_latex","title":"<code>to_latex()</code>","text":"<p>Renders the truth table as LaTex (with the <code>tabulate</code> library)</p> <p>Returns:</p> Type Description <code>str</code> <p>the LaTex output, which uses the <code>tabular</code> LaTex environment</p> Source code in <code>src\\logicalpy\\semantics.py</code> <pre><code>def to_latex(self) -&gt; str:\n    \"\"\"Renders the truth table as LaTex (with the `tabulate` library)\n\n    Returns:\n        (str): the LaTex output, which uses the `tabular` LaTex environment\n\n    \"\"\"\n    if self._latex_table is not None:\n        return self._latex_table\n\n    table_data = []\n\n    formula_props = sorted(list(self.formula.propositions()))\n    table_headers = formula_props + [self.formula.to_latex()]\n\n    truth_valuations_possible = product((True, False), repeat=len(formula_props))\n\n    for valuation in truth_valuations_possible:\n        valuation_dict = {prop: value for (prop, value) in zip(formula_props, valuation)}\n        if self.formula.is_satisfied(valuation_dict):\n            truth_value = \"T\"\n        else:\n            truth_value = \"F\"\n\n        table_data.append([\"T\" if val is True else \"F\" for val in valuation] + [truth_value])\n\n    latex_result = tabulate(table_data, headers=table_headers, tablefmt=\"latex_raw\")\n    # Add vertical bars between columns and remove very first horizontal bar\n    latex_result = re.sub(\n        r\"begin\\{tabular\\}\\{.+\\}\\n\\\\hline\",\n        r\"begin{tabular}{\" + \"|\".join([\"c\" for _ in range(len(table_headers))]) + \"}\",\n        latex_result,\n        count=1,\n    )\n    # Remove last horizontal bar\n    latex_result = latex_result.replace(r\"\\hline\" + \"\\n\" + r\"\\end{tabular}\", r\"\\end{tabular}\")\n    self._latex_table = latex_result\n    return self._latex_table\n</code></pre>"},{"location":"api-reference/logicalpy/semantics/#logicalpy.semantics.TruthTable.to_markdown","title":"<code>to_markdown()</code>","text":"<p>Renders the truth table as Markdown with the <code>tabulate</code> library</p> <p>Returns:</p> Type Description <code>str</code> <p>the Markdown truth table</p> Source code in <code>src\\logicalpy\\semantics.py</code> <pre><code>def to_markdown(self) -&gt; str:\n    \"\"\"Renders the truth table as Markdown with the `tabulate` library\n\n    Returns:\n        (str): the Markdown truth table\n\n    \"\"\"\n\n    if self._markdown_table is not None:\n        return self._markdown_table\n\n    table_data = []\n\n    formula_props = sorted(list(self.formula.propositions()))\n    table_headers = formula_props + [str(self.formula)]\n\n    truth_valuations_possible = product((True, False), repeat=len(formula_props))\n\n    for valuation in truth_valuations_possible:\n        valuation_dict = {prop: value for (prop, value) in zip(formula_props, valuation)}\n        if self.formula.is_satisfied(valuation_dict):\n            truth_value = \"T\"\n        else:\n            truth_value = \"F\"\n\n        table_data.append([\"T\" if val is True else \"F\" for val in valuation] + [truth_value])\n\n    self._str_table = tabulate(table_data, headers=table_headers, tablefmt=\"github\")\n    return self._str_table\n</code></pre>"},{"location":"api-reference/logicalpy/semantics/#logicalpy.semantics.TruthTable.to_str","title":"<code>to_str()</code>","text":"<p>Renders the truth table as a str with the <code>tabulate</code> library (style used: 'simple')</p> <p>Returns:</p> Type Description <code>str</code> <p>the truth table</p> Source code in <code>src\\logicalpy\\semantics.py</code> <pre><code>def to_str(self) -&gt; str:\n    \"\"\"Renders the truth table as a str with the `tabulate` library (style used: 'simple')\n\n    Returns:\n        (str): the truth table\n\n    \"\"\"\n\n    if self._str_table is not None:\n        return self._str_table\n\n    table_data = []\n\n    formula_props = sorted(list(self.formula.propositions()))\n    table_headers = formula_props + [str(self.formula)]\n\n    truth_valuations_possible = product((True, False), repeat=len(formula_props))\n\n    for valuation in truth_valuations_possible:\n        valuation_dict = {prop: value for (prop, value) in zip(formula_props, valuation)}\n        if self.formula.is_satisfied(valuation_dict):\n            truth_value = \"T\"\n        else:\n            truth_value = \"F\"\n\n        table_data.append([\"T\" if val is True else \"F\" for val in valuation] + [truth_value])\n\n    self._str_table = tabulate(table_data, headers=table_headers, tablefmt=\"simple\")\n    return self._str_table\n</code></pre>"},{"location":"api-reference/logicalpy/semantics/#logicalpy.semantics.all_satisfying_valuations","title":"<code>all_satisfying_valuations(formula)</code>","text":"<p>Returns all the valuations that satisfy the formula given</p> <p>Parameters:</p> Name Type Description Default <code>formula</code> <code>Formula</code> <p>the formula to test for valuations</p> required <p>Returns:</p> Type Description <code>list[dict[str, bool]]</code> <p>the list of all the valuations that satisfy the formula given. Each valuation is dictionary mapping each proposition name to a truth value (bool)</p> Source code in <code>src\\logicalpy\\semantics.py</code> <pre><code>def all_satisfying_valuations(formula: Formula) -&gt; list[dict[str, bool]]:\n    \"\"\"Returns all the valuations that satisfy the formula given\n\n    Args:\n        formula: the formula to test for valuations\n\n    Returns:\n        (list[dict[str, bool]]): the list of all the valuations that satisfy the formula given.\n            Each valuation is dictionary mapping each proposition name to a truth value (bool)\n\n    \"\"\"\n\n    formula_props = list(formula.propositions())\n\n    truth_valuations_possible = product((False, True), repeat=len(formula_props))\n\n    satisfying_valuations = []\n\n    for valuation in truth_valuations_possible:\n        valuation_dict = {prop: value for (prop, value) in zip(formula_props, valuation)}\n        if formula.is_satisfied(valuation_dict):\n            satisfying_valuations.append(valuation_dict)\n    return satisfying_valuations\n</code></pre>"},{"location":"api-reference/logicalpy/semantics/#logicalpy.semantics.are_equivalent","title":"<code>are_equivalent(formula_1, formula_2)</code>","text":"<p>Tests whether two formulae are (semantically) equivalent</p> <p>Parameters:</p> Name Type Description Default <code>formula_1</code> <code>Formula</code> <p>the first formula to test</p> required <code>formula_2</code> <code>Formula</code> <p>the second formula to test</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the two formulae given are semantically equivalent, and False otherwise</p> Source code in <code>src\\logicalpy\\semantics.py</code> <pre><code>def are_equivalent(formula_1: Formula, formula_2: Formula) -&gt; bool:\n    \"\"\"Tests whether two formulae are (semantically) equivalent\n\n    Args:\n        formula_1: the first formula to test\n        formula_2: the second formula to test\n\n    Returns:\n        (bool): True if the two formulae given are semantically equivalent, and False otherwise\n\n    \"\"\"\n\n    formula_props = list(formula_1.propositions().union(formula_2.propositions()))\n\n    truth_valuations_possible = product((False, True), repeat=len(formula_props))\n\n    for valuation in truth_valuations_possible:\n        valuation_dict = {prop: value for (prop, value) in zip(formula_props, valuation)}\n        if formula_1.is_satisfied(valuation_dict) != formula_2.is_satisfied(valuation_dict):\n            return False\n    return True\n</code></pre>"},{"location":"api-reference/logicalpy/semantics/#logicalpy.semantics.are_jointly_satisfiable","title":"<code>are_jointly_satisfiable(*formulae)</code>","text":"<p>Tests whether several formulae are jointly satisfiable</p> <p>Parameters:</p> Name Type Description Default <code>*formulae</code> <code>Formula</code> <p>the formulae to test for satisfiability</p> <code>()</code> <p>Returns:</p> Type Description <code>bool</code> <p>True, if the formulae are satisfiable, and False otherwise</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>if one or less formulae are given</p> Source code in <code>src\\logicalpy\\semantics.py</code> <pre><code>def are_jointly_satisfiable(*formulae: Formula) -&gt; bool:\n    \"\"\"Tests whether several formulae are jointly satisfiable\n\n    Args:\n        *formulae (Formula): the formulae to test for satisfiability\n\n    Returns:\n        (bool): True, if the formulae are satisfiable, and False otherwise\n\n    Raises:\n        ValueError: if one or less formulae are given\n\n    \"\"\"\n    if len(formulae) &lt;= 1:\n        raise ValueError(\"cannot test consistency for 1 formula or less\")\n\n    props = []\n    for formula in formulae:\n        props.extend(formula.propositions())\n\n    truth_valuations_possible = product((False, True), repeat=len(props))\n\n    for valuation in truth_valuations_possible:\n        valuation_dict = {prop: value for (prop, value) in zip(props, valuation)}\n        if all([formula.is_satisfied(valuation_dict) for formula in formulae]):\n            return True\n    return False\n</code></pre>"},{"location":"api-reference/logicalpy/semantics/#logicalpy.semantics.is_satisfiable","title":"<code>is_satisfiable(formula)</code>","text":"<p>Tests whether a formula is satisfiable</p> <p>Parameters:</p> Name Type Description Default <code>formula</code> <code>Formula</code> <p>the formula to test</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the formula given is satisfiable, and False otherwise</p> Source code in <code>src\\logicalpy\\semantics.py</code> <pre><code>def is_satisfiable(formula: Formula) -&gt; bool:\n    \"\"\"Tests whether a formula is satisfiable\n\n    Args:\n        formula (Formula): the formula to test\n\n    Returns:\n        (bool): True if the formula given is satisfiable, and False otherwise\n\n    \"\"\"\n\n    formula_props = list(formula.propositions())\n\n    truth_valuations_possible = product((False, True), repeat=len(formula_props))\n\n    for valuation in truth_valuations_possible:\n        valuation_dict = {prop: value for (prop, value) in zip(formula_props, valuation)}\n        if formula.is_satisfied(valuation_dict):\n            return True\n    return False\n</code></pre>"},{"location":"api-reference/logicalpy/semantics/#logicalpy.semantics.is_tautology","title":"<code>is_tautology(formula)</code>","text":"<p>Tests whether a formula is a tautology</p> <p>Parameters:</p> Name Type Description Default <code>formula</code> <code>Formula</code> <p>the formula to test</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the formula given is a tautology, and False otherwise</p> Source code in <code>src\\logicalpy\\semantics.py</code> <pre><code>def is_tautology(formula: Formula) -&gt; bool:\n    \"\"\"Tests whether a formula is a tautology\n\n    Args:\n        formula (Formula): the formula to test\n\n    Returns:\n        (bool): True if the formula given is a tautology, and False otherwise\n\n    \"\"\"\n\n    formula_props = list(formula.propositions())\n\n    truth_valuations_possible = product((False, True), repeat=len(formula_props))\n\n    for valuation in truth_valuations_possible:\n        valuation_dict = {prop: value for (prop, value) in zip(formula_props, valuation)}\n        if not formula.is_satisfied(valuation_dict):\n            return False\n    return True\n</code></pre>"},{"location":"api-reference/logicalpy/semantics/#logicalpy.semantics.is_valid_argument","title":"<code>is_valid_argument(premises, conclusion)</code>","text":"<p>Tests whether an argument is (semantically) valid, i.e. whether the premises given entail the conclusion given</p> <p>Parameters:</p> Name Type Description Default <code>premises</code> <code>Iterable[Formula]</code> <p>the premises of the argument</p> required <code>conclusion</code> <code>Formula</code> <p>the conclusion of the argument</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the argument is valid, and False otherwise</p> Source code in <code>src\\logicalpy\\semantics.py</code> <pre><code>def is_valid_argument(premises: Iterable[Formula], conclusion: Formula) -&gt; bool:\n    \"\"\"Tests whether an argument is (semantically) valid, i.e. whether the premises given entail the conclusion given\n\n    Args:\n        premises (Iterable[Formula]): the premises of the argument\n        conclusion (Formula): the conclusion of the argument\n\n    Returns:\n        (bool): True if the argument is valid, and False otherwise\n\n    \"\"\"\n\n    all_props_set = set()\n    for premise in premises:\n        all_props_set = all_props_set.union(premise.propositions())\n    all_props_set = all_props_set.union(conclusion.propositions())\n\n    argument_props = list(all_props_set)\n\n    truth_valuations_possible = product((False, True), repeat=len(argument_props))\n\n    for valuation in truth_valuations_possible:\n        valuation_dict = {prop: value for (prop, value) in zip(argument_props, valuation)}\n\n        all_premises_true = True\n\n        for premise in premises:\n            if not premise.is_satisfied(valuation_dict):  # at least one premise is False under the current valuation\n                all_premises_true = False\n                break\n\n        if all_premises_true:\n            if not conclusion.is_satisfied(valuation_dict):\n                return False\n\n    return True\n</code></pre>"},{"location":"api-reference/logicalpy/semantics/#logicalpy.semantics.one_satisfying_valuation","title":"<code>one_satisfying_valuation(formula)</code>","text":"<p>Returns one valuation that satisfies the formula given</p> <p>Parameters:</p> Name Type Description Default <code>formula</code> <code>Formula</code> <p>the formula to test with valuations</p> required <p>Returns:</p> Type Description <code>Optional[dict[str, bool]]</code> <p>a valuation that satisfies the formula if it exists, and None otherwise</p> Source code in <code>src\\logicalpy\\semantics.py</code> <pre><code>def one_satisfying_valuation(formula: Formula) -&gt; Optional[dict[str, bool]]:\n    \"\"\"Returns one valuation that satisfies the formula given\n\n    Args:\n        formula: the formula to test with valuations\n\n    Returns:\n        (Optional[dict[str, bool]]): a valuation that satisfies the formula if it exists, and None otherwise\n\n    \"\"\"\n\n    formula_props = list(formula.propositions())\n\n    truth_valuations_possible = product((False, True), repeat=len(formula_props))\n\n    for valuation in truth_valuations_possible:\n        valuation_dict = {prop: value for (prop, value) in zip(formula_props, valuation)}\n        if formula.is_satisfied(valuation_dict):\n            return valuation_dict\n    return None\n</code></pre>"},{"location":"usage/constructing-formulae/","title":"Constructing Formulae with LogicalPy","text":"<p>With LogicalPy, propositional formulae (class <code>Formula</code>) can be constructed in three different ways:</p>"},{"location":"usage/constructing-formulae/#using-the-formula-parser","title":"Using the formula parser","text":"<p>You can use the propositional parser built with <code>lark</code>, with the class method <code>Formula.from_string()</code>. Propositions consist of one or several letters, optionally followed by one several digits. The connectives are as follow:</p> Name Symbols Negation <code>~</code> or <code>\u00ac</code> Conjunction <code>&amp;</code> or <code>\u2227</code> Disjunction <code>v</code>, <code>|</code> or <code>\u2228</code> Implication <code>-&gt;</code>, <code>\u2192</code> or <code>\u21d2</code> Bi-implication <code>&lt;-&gt;</code>, <code>\u2194</code> or <code>\u21d4</code> <pre><code>from logicalpy import Formula\n\nfml = Formula.from_string(\"(~P &amp; (P -&gt; Q)) &lt;-&gt; P\")\n\nprint(fml)\n</code></pre> <p>Output:</p> <pre><code>(\u00acP \u2227 (P \u2192 Q)) \u2194 P\n</code></pre>"},{"location":"usage/constructing-formulae/#using-the-overloaded-operators","title":"Using the overloaded operators","text":"<p>You can also use the overloaded logical operators: <code>&amp;</code> for and, <code>|</code> for or, <code>&gt;&gt;</code> for implies, and <code>~</code> for not, to form a formula from propositions (class <code>Proposition</code>). Example:</p> <pre><code>from logicalpy import Formula, Proposition\n\nP = Proposition(\"P\")\nQ = Proposition(\"Q\")\n\nfml = (~P &amp; (P &gt;&gt; Q)) | P\n\nprint(fml)\n</code></pre> <p>Output:</p> <pre><code>(\u00acP \u2227 (P \u2192 Q)) \u2228 P\n</code></pre>"},{"location":"usage/constructing-formulae/#directly-using-the-base-classes","title":"Directly using the base classes","text":"<p>Finally, you can directly use the base classes <code>Proposition</code>, <code>Not</code>, <code>And</code>, <code>Or</code>, <code>Implies</code> and <code>BiImplies</code>. Example:</p> <pre><code>from logicalpy import Formula, Proposition, And, Or, Not, Implies, BiImplies\n\nP = Proposition(\"P\")\nQ = Proposition(\"Q\")\n\nfml = Formula(Or(And(Not(P), Implies(P, Q)), P))\n\nprint(fml)\n</code></pre> <p>Output:</p> <pre><code>(\u00acP \u2227 (P \u2192 Q)) \u2228 P\n</code></pre>"},{"location":"usage/normal-forms/","title":"Normal Forms","text":"<p>The conversion to normal forms is implemented in the <code>normal_forms</code> sub-module.</p>"},{"location":"usage/normal-forms/#cnf-and-dnf","title":"CNF and DNF","text":"<p>Formulae can be converted to CNF (Conjunctive Normal Form) or to DNF (Disjunctive Normal Form) with the <code>to_cnf()</code> and <code>to_dnf()</code> functions, which return an equivalent <code>Formula</code> in normal form. The normal forms found are not canonical forms. Instead of using truth tables, the functions use the following rewriting rules:</p> <ol> <li> <p>All conditionals and biconditionals are removed using the rules:</p> \\[A \\leftrightarrow B \\equiv (A \\to B) \\land (B \\to A)\\] \\[A \\to B \\equiv \\neg A \\lor B\\] </li> <li> <p>Then negations are moved inwards, with De Morgan's laws:</p> \\[\\neg (A \\lor B) \\equiv \\neg A \\land \\neg B\\] \\[\\neg (A \\land B) \\equiv \\neg A \\lor \\neg B\\] <p>Double negations are removed:</p> \\[\\neg \\neg A \\equiv A\\] <p>And at this point, NNF (Negation Normal Form) is obtained. You can directly use the <code>to_nnf()</code> function to convert a formula to NNF.</p> </li> <li> <p>Finally:</p> <ul> <li>If the desired form is CNF, we distribute disjunctions over conjunctions:</li> </ul> \\[A \\lor (B \\land C) \\equiv (A \\lor B) \\land (A \\lor C)\\] <ul> <li>If the desired form is DNF, we distribute conjunctions over disjunctions:</li> </ul> \\[A \\land (B \\lor C) \\equiv (A \\land B) \\lor (A \\land C)\\] </li> </ol> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from logicalpy import Formula\n&gt;&gt;&gt; from logicalpy.normal_forms import to_cnf, to_dnf\n&gt;&gt;&gt; fml = Formula.from_string(\"~P -&gt; ~(Q v P)\")\n&gt;&gt;&gt; print(to_dnf(fml))\nP \u2228 (\u00acQ \u2227 \u00acP)\n&gt;&gt;&gt; print(to_cnf(fml))\n(P \u2228 \u00acQ) \u2227 (P \u2228 \u00acP)\n</code></pre>"},{"location":"usage/normal-forms/#clausal-representations-of-normal-forms","title":"Clausal representations of normal forms","text":"<p>The <code>normal_forms</code> sub-module also contains classes representing conjunctive and disjunctive clauses. The CNF and DNF forms can be found in terms of clauses with the <code>to_clausal_cnf()</code> and <code>to_clausal_dnf()</code> functions. With <code>to_cnf()</code> and <code>to_dnf()</code>, the resulting normal forms are <code>Formula</code> instances, so disjunction and conjunction are represented as binary operators, but with <code>to_clausal_cnf()</code> and <code>to_clausal_dnf()</code>, the results are lists of clauses. Note that the resulting clauses aren't simplified.</p> <p></p> <p>For a complete reference of the <code>normal_forms</code> sub-module, see the corresponding API reference.</p>"},{"location":"usage/resolution-theorem-proving/","title":"Resolution Theorem Proving","text":"<p>The <code>resolution</code> sub-module can be used for propositional resolution proving.</p>"},{"location":"usage/resolution-theorem-proving/#usage","title":"Usage","text":"<p>The class <code>ResolutionProver</code> is used for automated resolution refutation. Its constructor takes the premises of the logical argument as an iterable containing <code>Formula</code> objects, and and the conclusion to prove as a <code>Formula</code> as well. The <code>prove()</code> method returns (a tuple containing) two objects:</p> <ul> <li>Whether a contradiction was derived from the premises and the negated conclusion</li> <li>The full resolution proof as a <code>str</code></li> </ul> <p>See the example below for a proof of \\(A \\lor B, A \\to C, B \\to C \\vdash C\\):</p> <pre><code>from logicalpy import Formula, Proposition, Or, Implies\nfrom logicalpy.resolution import ResolutionProver\n\npremises = [\n    Formula.from_string(\"A v B\"),\n    Formula.from_string(\"A -&gt; C\"),\n    Formula.from_string(\"B -&gt; C\")\n]\n\nconclusion = Formula.from_string(\"C\")\n\nprover = ResolutionProver(premises=premises, conclusion=conclusion)\n\nrefutation_found, proof_str = prover.prove()\n\nprint(\"Refutation found:\", refutation_found)\n\nprint(\"\\nProof:\\n\" + proof_str)\n</code></pre> <p>Output:</p> <pre><code>Refutation found: True\n\nProof:\nResolution proof for argument A \u2228 B, A \u2192 C, B \u2192 C \u2234 C\n\n1. (A \u2228 B)                    Premise clause\n2. (\u00acA \u2228 C)                   Premise clause\n3. (\u00acB \u2228 C)                   Premise clause\n4. \u00acC                         Negated conclusion clause\n5. (B \u2228 C)                    Resolve 1, 2\n6. (A \u2228 C)                    Resolve 1, 3\n7. \u00acA                         Resolve 2, 4\n8. B                          Resolve 1, 7\n9. C                          Resolve 2, 6\n10. \u25fb                         Resolve 4, 9\n\nRefutation found: conclusion valid\n</code></pre> <p></p> <p>For a complete reference of the <code>resolution</code> sub-module, see the corresponding API reference.</p>"},{"location":"usage/semantic-functions/","title":"Semantic Functions","text":"<p>Semantics functions are contained in the <code>semantics</code> sub-module. They include:</p>"},{"location":"usage/semantic-functions/#truth-tables","title":"Truth tables","text":"<p>Truth tables can be built using the <code>TruthTable</code> class. Then, the string representation of the truth table can be found with the <code>to_str</code> method (or directly with the <code>str</code> built-in constructor). You can also use the <code>to_latex()</code> or <code>to_markdown()</code> methods to render the truth table to LaTex or Markdown.</p> <p>Example:</p> <pre><code>&gt;&gt;&gt; from logicalpy import Formula\n&gt;&gt;&gt; from logicalpy.semantics import TruthTable\n&gt;&gt;&gt; fml = Formula.from_string(\"P v (~Q &amp; ~P)\")\n&gt;&gt;&gt; truth_table = TruthTable(fml)\n&gt;&gt;&gt; print(truth_table)\nP    Q    P \u2228 (\u00acQ \u2227 \u00acP)\n---  ---  ---------------\nT    T    T\nT    F    T\nF    T    F\nF    F    T\n&gt;&gt;&gt; print(truth_table.to_latex())\n\\begin{tabular}{c|c|c}\n P   &amp; Q   &amp; $P \\lor (\\neg Q \\land \\neg P)$   \\\\\n\\hline\n T   &amp; T   &amp; T                                \\\\\n T   &amp; F   &amp; T                                \\\\\n F   &amp; T   &amp; F                                \\\\\n F   &amp; F   &amp; T                                \\\\\n\\end{tabular}\n&gt;&gt;&gt; print(truth_table.to_markdown())\n| P   | Q   | P \u2228 (\u00acQ \u2227 \u00acP)   |\n|-----|-----|-----------------|\n| T   | T   | T               |\n| T   | F   | T               |\n| F   | T   | F               |\n| F   | F   | T               |\n</code></pre> <p>The above Markdown renders as follow:</p> P Q P \u2228 (\u00acQ \u2227 \u00acP) T T T T F T F T F F F T <p>Note</p> <p>The LaTex code generated for a truth table uses the <code>tabular</code> environment, and it cannot be rendered using MathJax, but only using a pure LaTex compiler. Here is how the above LaTex code generated would render:</p> <p> </p>"},{"location":"usage/semantic-functions/#satisfiabilityconsistency-test","title":"Satisfiability/consistency test","text":"<p>To check whether a formula is satisfiable, use the <code>is_satisfiable()</code> function. For getting one satisfying assignment for the formula, use the <code>one_satisfying_valuation()</code> function. For getting all of them, the <code>all_satisfying_valuations()</code> function can be used. To check whether several formulae are jointly satisfiable, use the function <code>are_jointly_satisfiable()</code>.</p> <p>Example:</p> <pre><code>&gt;&gt;&gt; from logicalpy import Formula\n&gt;&gt;&gt; from logicalpy.semantics import *\n&gt;&gt;&gt; # With one formula:\n&gt;&gt;&gt; fml = Formula.from_string(\"P -&gt; Q\")\n&gt;&gt;&gt; is_satisfiable(fml)\nTrue\n&gt;&gt;&gt; one_satisfying_valuation(fml)\n{'P': False, 'Q': False}\n&gt;&gt;&gt; all_satisfying_valuations(fml)\n[{'P': False, 'Q': False}, {'P': False, 'Q': True}, {'P': True, 'Q': True}]\n&gt;&gt;&gt; # With several formulae:\n&gt;&gt;&gt; are_jointly_satisfiable(Formula.from_string(\"P &lt;-&gt; Q\"), Formula.from_string(\"~P &amp; Q\"))\nFalse\n</code></pre> <p></p> <p>For a complete reference of the <code>semantics</code> sub-module, see the corresponding API reference.</p>"},{"location":"usage/using-formulae/","title":"Using Formulae","text":""},{"location":"usage/using-formulae/#latex-rendering","title":"Latex Rendering","text":"<p>Formulae can be rendered as LaTex code, with the <code>to_latex()</code> method of <code>Formula</code> objects. Example:</p> <pre><code>&gt;&gt;&gt; from logicalpy import Formula\n&gt;&gt;&gt; test_formula = Formula.from_string(\"(P -&gt; (~P &amp; P)) v Q\")\n&gt;&gt;&gt; print(test_formula.to_latex())\n$(P \\to (\\neg P \\land P)) \\lor Q$\n</code></pre> <p>The above LaTex would render as follow: \\((P \\to (\\neg P \\land P)) \\lor Q\\)</p>"},{"location":"usage/using-formulae/#formula-propositions","title":"Formula Propositions","text":"<p>You can get the set of all the propositions of a formula (with every proposition represented by its name) with the <code>propositions()</code> method of the <code>Formula</code> class:</p> <pre><code>&gt;&gt;&gt; from logicalpy import Formula\n&gt;&gt;&gt; test_formula = Formula.from_string(\"P -&gt; Q\")\n&gt;&gt;&gt; test_formula.propositions()\n{'P', 'Q'}\n</code></pre>"},{"location":"usage/using-formulae/#semantic-valuation","title":"Semantic Valuation","text":"<p><code>Formula</code> objects can be tested with a particular valuation, with the <code>is_satisfied()</code> method. This method takes a valuation as a <code>dict</code> associating each proposition name (<code>str</code>) with a truth value (<code>bool</code>) and returns whether the <code>Formula</code> is satisfied by the valuation. Example:</p> <pre><code>&gt;&gt;&gt; from logicalpy import Formula\n&gt;&gt;&gt; test_formula = Formula.from_string(\"P &amp; Q\")\n&gt;&gt;&gt; test_formula.is_satisfied({\"P\": True, \"Q\": False})\nFalse\n&gt;&gt;&gt; test_formula.is_satisfied({\"P\": True, \"Q\": True})\nTrue\n</code></pre> <p></p> <p>For a complete reference of the <code>Formula</code> class, see the API reference.</p>"}]}